# Obsidian 插件开发文档：Review Scheduler

## 概述
Review Scheduler 是一个 Obsidian 插件，用于对带有 `review` 标签的笔记进行智能排程。该插件的目标是帮助用户按照 SuperMemo 风格的间隔重复法进行复习，从而优化学习效果。
本项目使用 TypeScript 开发，并借助 esbuild 进行快速构建。

## 功能特点
- **自动排程**：基于简单的间隔重复算法，为笔记计算下一次复习时间。
- **复习队列**：维护一个待复习的笔记队列，每日自动推送需要复习的笔记。
- **用户交互**：
  - `Next`：按照算法计算下次复习时间并重新排程。
  - `搁置`：将笔记移出复习队列，不再进行排程。

## 排程算法
插件使用一个极其简单的排程算法计算下一次复习时间：
```javascript
const newInterval = Math.ceil(multiplier ** Math.max(repHistory.length, 1));
```
其中：
- `multiplier` 默认为 `1.5`，可由用户配置。
- `repHistory.length` 代表该笔记的复习次数，初始值为 `0`。
- `Math.ceil` 确保间隔天数为整数。

## 交互流程
1. 用户在 Obsidian 中打开插件。+
2. 插件自动检测所有带 `review` 标签的笔记，并生成每日复习列表。
3. 用户点击 `Next` 进行复习，系统根据算法更新下一次复习时间。
4. 若用户选择 `搁置`，笔记将被移出复习队列，不再参与排程。

## 技术实现
- **插件框架**：使用 Obsidian 官方 API 进行插件开发。
- **数据存储**：利用 Obsidian 的 metadata 记录笔记的复习时间与历史。
- **界面交互**：使用 Obsidian 的 UI 组件，实现用户友好的交互体验。

## 核心架构与逻辑

### 数据模型 (Interfaces)
*   `ReviewNote`: 定义了复习笔记的核心数据结构，包含 `TFile` 对象、复习日期 `reviewDate`、复习历史 `repHistory` 和优先级 `priority`。
*   `ReviewSchedulerSettings`: 定义了所有可在设置面板中配置的选项，包括算法参数、行为开关和快捷键。

### 主插件类 (`ReviewSchedulerPlugin`)
作为插件的入口和控制器，`ReviewSchedulerPlugin` 负责：
*   加载和保存设置。
*   注册所有命令、视图和事件监听器。
*   实现所有核心业务逻辑，如笔记扫描、排序、排程计算和用户操作处理。

### 视图类 (`ReviewSchedulerView`)
`ReviewSchedulerView` 负责渲染侧边栏的用户界面。其核心逻辑已重构，以提升性能和用户体验：
*   **`render()`**: 此函数负责**完全重绘**整个视图。它会保存并恢复滚动位置，以避免在列表刷新时跳动。它只在数据源（`reviewQueue`）发生重大变化时调用。
*   **`updateHighlights()`**: 这是一个轻量级函数，**仅更新**列表中项目的 CSS 高亮类，而**不重绘**任何 DOM 元素。它由 `active-leaf-change` 事件触发，实现了高亮状态与活动笔记的瞬时同步，且不会影响滚动位置。

### 事件处理 (Event Handling)
*   文件系统事件 (`vault.on`, `metadataCache.on`): 用于监听笔记的增删改。这些事件通过 `debounce` 函数进行防抖处理，避免因高频触发而导致的性能问题。
*   工作区事件 (`workspace.on('active-leaf-change')`): 用于实时更新侧边栏的高亮，确保其与用户当前查看的笔记同步。

## 核心功能实现详解

### 笔记扫描与排序 (`scanNotesForReview`)
这是插件最核心的函数之一，负责生成有序的复习队列。其执行流程如下：
1.  **数据收集**：遍历所有 Markdown 文件，筛选出包含 `review` 标签的笔记，并解析其元数据。
2.  **稳定排序**：对所有找到的笔记进行一次全局的、稳定的排序。主键为 `reviewDate` (升序)，次键为 `file.stat.ctime` (升序)，确保了排序的唯一性和可预测性。
3.  **分组**：将队列分为“今日到期”（`dueNotes`）和“即将到来”（`upcomingNotes`）两部分。
4.  **优先级分组**：将 `dueNotes` 进一步细分为 `high`, `medium`, `low`, `none` 四个子数组。
5.  **优先级随机提升**：如果用户开启此功能，则按设定的概率 (`promotionChance`) 将部分 `low` 组的笔记移入 `medium` 组，部分 `medium` 组的笔记移入 `high` 组。
6.  **条件性乱序**：如果用户开启 `enableShuffle`，则对每个优先级子数组（`high`, `medium`, `low`, `none`）分别执行 Fisher-Yates shuffle 算法进行内部乱序。如果关闭，则各组将保持第2步的稳定排序结果。
7.  **队列重建**：按 `high -> medium -> low -> none -> upcoming` 的顺序将所有数组拼接起来，形成最终的 `reviewQueue`。
8.  **新笔记插入**：如果函数被调用时传入了 `newNotePath` 参数，它会在队列重建后，将这个新笔记精准地插入到当前活动笔记的下一个位置。

### 用户操作处理 (`handleAction`)
这是一个统一处理“下一步”和“搁置”操作的函数，以实现逻辑复用。
1.  **状态记录**：在执行任何操作前，记录当前笔记在“今日到期”列表中的索引及其下一个笔记。这是实现“跳转到下一篇”功能的关键。
2.  **执行操作**：根据是“下一步”还是“搁置”，分别更新笔记元数据或移除复习标签。
3.  **重新扫描**：操作完成后，调用 `scanNotesForReview()` 刷新整个队列。
4.  **关闭标签页**：关闭刚刚处理完的笔记的标签页。
5.  **条件性跳转**：根据用户的 `jumpAfterReview` 设置，决定下一步行为：
    *   `'off'`: 不做任何事。
    *   `'next'`: 尝试打开第1步中记录的“下一篇”笔记。
    *   `'top'`: 打开新队列的队首笔记（这也是 `'next'` 失败时的后备行为）。

### 上下文感知 (`getNoteForAction`)
此函数确保了所有命令都能智能地作用于正确的笔记。
1.  **优先当前**：首先检查工作区中是否有激活的 `MarkdownView`，如果有，则查找该文件是否在复习队列中。
2.  **备选队首**：如果找不到激活的复习笔记，则回退到选择“今日到期”队列的第一个笔记作为操作目标。


## 未来改进方向
- 提供复习统计数据，如复习频率、遗忘曲线等。
- 添加复习提醒功能，提高用户的复习效率。
- 在侧边栏视图中为每个列表项添加右键菜单，提供快捷操作。

